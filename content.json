{"meta":{"title":"租船","subtitle":null,"description":null,"author":"Stay","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"有哪些大家不说，但需要知道的社会规则？","slug":"有哪些大家不说，但需要知道的社会规则？","date":"2017-09-30T03:01:13.000Z","updated":"2017-09-30T03:05:48.681Z","comments":true,"path":"2017/09/30/有哪些大家不说，但需要知道的社会规则？/","link":"","permalink":"http://yoursite.com/2017/09/30/有哪些大家不说，但需要知道的社会规则？/","excerpt":"作者：寂寂无名链接：https://www.zhihu.com/question/64351318/answer/237138055来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.别人的微信一定要及时回复，别人的朋友圈评论一定要回复，否则会被敏感的人认为你不尊重他，轻视他。2.别人说话的时候不要玩手机，理由同上。3.工作的时候不要玩手机，哪怕你闲着，否则被领导看了，会认为你不认真，态度不端正。4.男人喜欢当老师，喜欢被人拍马屁，喜欢别人的崇拜，喜欢显示自己。女人喜欢当孩子，喜欢被呵护，喜欢无忧无虑，不用为生活，工作操心。掌握这些，即使其貌不扬，也能寻得如意眷属，婚姻幸福。","text":"作者：寂寂无名链接：https://www.zhihu.com/question/64351318/answer/237138055来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.别人的微信一定要及时回复，别人的朋友圈评论一定要回复，否则会被敏感的人认为你不尊重他，轻视他。2.别人说话的时候不要玩手机，理由同上。3.工作的时候不要玩手机，哪怕你闲着，否则被领导看了，会认为你不认真，态度不端正。4.男人喜欢当老师，喜欢被人拍马屁，喜欢别人的崇拜，喜欢显示自己。女人喜欢当孩子，喜欢被呵护，喜欢无忧无虑，不用为生活，工作操心。掌握这些，即使其貌不扬，也能寻得如意眷属，婚姻幸福。5.在朋友圈成天打鸡血的一般混得不怎么样，或者文化偏低。6.成天和你聊情商，人脉，资源的，本身学校垃圾，学历低，无一技之长，本身的人脉，情商，资源也质量堪忧。7.一个人的认知水平决定了他的命运。比如做传销的人一定认为传销是最伟大的事业，苦三年，拼三年，百万年薪不是梦。那他就是传销的命运，可悲的命运。8.一个人如果没有清晰的，可复制的目标，他十有八九会走弯路。那些嚷嚷着年轻要敢闯，要有勇气做自己，要赚大钱，当ceo的，三十岁的时候往往还在颠沛流离，难以立足。9.年轻的时候稳定压倒一切，在好的环境中稳中求进才是上策，否则一步之差死无葬身之地。你无需创新，只要复制成功前辈的路就好。创新的人往往不得善终。比如有些人毕业去创业，去创业公司，去做销售（包括保险，直销，传销），基本上凶多吉少。环境太恶劣势必会影响一颗树的生长。没人给你兜底，风险自担，很多人为此懊悔终生。10.和你有利益相关的人不能轻信。比如HR招人都是说的好听，说是进来做飞机，其实是拧螺丝，这种人太多了。比如销售肯定说自己卖的产品是最好的。比如保险公司的领导一定说保险是最光明的事业。11.不要以为吸烟或者陪酒就能搞定生意，就能得到单子，不做这些就不行。你的价值和对方的需求才是关键，讨好与迎合并不是做生意的关键。做人如果带着乞丐的气息，怕老板不喜欢自己，怕对方不给自己单子，终不是长久之计。12.你没价值，点再多赞，人家依旧不鸟你。13.没有一技之长，即使是名校毕业，依旧会没有安全感。14.说你好不代表对方真的认为你好，说你不行不代表真的认为你不行。往往批评你的人才真的看得起你。15.看人要从侧面看（看他对周围人如何），从反面看（看他在压力下如何反应，对讨厌的人如何反应）16.谈恋爱时不要太猴急，色迷心窍，先了解对方的为人，历史，性格，否则前有马蓉，后有翟欣欣，欣欣向蓉，搁谁也吃不消。17.一般看一个女人先看她情绪稳不稳定，报复心强不强，喜不喜欢抱怨，指责别人，挑不挑剔。如果有这些毛病，在一起会很累。18.男人想要女人温柔如初而不是变成怨妇，女强人，就勤快点，主动点，多做家务，多担当点事。否则就是给自己下半生埋雷。19.世界虽大，出去看看前先掂量下自己的学历，技能，学校，履历，很多骂体制的人不知道出了体制他们屁都不是。20.读书上名校，学习技能是大多数人最快，把握最大的上升途径。21.都说改行穷三年，其实不改行穷一辈子。22.老板的鸡血听听就好，不要当真。中国老板最喜欢的是给员工看稻盛和夫，日企的薪水福利保障却绝口不提。23.有相当一部分中国爸爸对家庭，孩子不管不问，放养，好像不存在一样。对外人则热心备至。这种人小心老了孩子不理你，老婆不理你，当你不存在。人在做，天在看。很多事，你迟了就不必到了。24.在中国要按规律办事，按规则办事，标新立异，不是受欢迎的人，你老是失败，别人看你就是loser,失败者，看你笑话，没人听你的情怀，你的故事。25.说话前先想想有没有话语权，不然你说出来没人理像空气一样，就尴尬了。那真是想钻地下藏起来。26.愚蠢的人以为自己认可的就是对的，自己不认可的就是错的。却不知道世界上有客观规律，不会因为你不承认而失效。","categories":[],"tags":[]},{"title":"给年轻人的职场建议","slug":"给年轻人的职场建议","date":"2017-09-25T01:09:53.000Z","updated":"2017-09-25T01:57:33.279Z","comments":true,"path":"2017/09/25/给年轻人的职场建议/","link":"","permalink":"http://yoursite.com/2017/09/25/给年轻人的职场建议/","excerpt":"","text":"–转自 亡羊补牢的老杨同志1.踏踏实实的做具体工作2.凡事不求人3.默默无闻能忍能让4.总把希望寄托在别人身上5.容易被感动、被激发、意气用事6.瞧不起同事7.知无不言言无不尽8.把单位当成慈善机构","categories":[],"tags":[]},{"title":"Activity相关","slug":"Activity相关","date":"2017-09-21T02:06:10.000Z","updated":"2017-09-21T02:44:43.947Z","comments":true,"path":"2017/09/21/Activity相关/","link":"","permalink":"http://yoursite.com/2017/09/21/Activity相关/","excerpt":"1.启动Activity，系统会首先调用oncreate(),onStart(),最后调用onResume(),Activity进入运行状态。2.当前Activity被其他Activity覆盖或锁屏时，调用onPause(),暂停当前Activity的运行。3.当前Activity由被覆盖状态回到前台或解锁屏时，系统会调用onResume()方法,再次进入运行状态。4.当前Activity转到新的Activity界面或按HOME键回到主屏，自身退居后台，会先调用onPause，然后调用onStop()方法，进入停滞状态。5.用户后退回到此Activity，系统会先调用onRestart()方法，然后调用onStart()方法，最后调用onResume()方法，再次进入运行状态。","text":"1.启动Activity，系统会首先调用oncreate(),onStart(),最后调用onResume(),Activity进入运行状态。2.当前Activity被其他Activity覆盖或锁屏时，调用onPause(),暂停当前Activity的运行。3.当前Activity由被覆盖状态回到前台或解锁屏时，系统会调用onResume()方法,再次进入运行状态。4.当前Activity转到新的Activity界面或按HOME键回到主屏，自身退居后台，会先调用onPause，然后调用onStop()方法，进入停滞状态。5.用户后退回到此Activity，系统会先调用onRestart()方法，然后调用onStart()方法，最后调用onResume()方法，再次进入运行状态。6.当前Activity处于被覆盖状态后者后台不可见状态时，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity需要再次调用onCreate()方法，onStart()方法，onResume()方法，而后进入运行状态。隶属内容7.用户退出当前Activity:系统会先调用onPause()方法，然后调用onStop()方法，最后调用onDestory()方法，结束当前Activity。","categories":[],"tags":[]},{"title":"道路通行速度知识点","slug":"道路通行速度知识点","date":"2017-09-15T07:13:02.000Z","updated":"2017-09-15T07:27:02.502Z","comments":true,"path":"2017/09/15/道路通行速度知识点/","link":"","permalink":"http://yoursite.com/2017/09/15/道路通行速度知识点/","excerpt":"","text":"没有道路中心线的道路，城市道路为每小时30公里，公路为每小时40公里；同方向只有一条机 动车的道路，城市道路为每小时50公里，公路为每小时70公里。 fd;kjfl;jdf","categories":[],"tags":[]},{"title":"喂，有船嘛？","slug":"Android事件分发机制详解：史上最全面、最易懂","date":"2017-09-07T08:31:00.000Z","updated":"2017-09-07T09:18:51.388Z","comments":true,"path":"2017/09/07/Android事件分发机制详解：史上最全面、最易懂/","link":"","permalink":"http://yoursite.com/2017/09/07/Android事件分发机制详解：史上最全面、最易懂/","excerpt":"","text":"Android事件分发机制详解：史上最全面、最易懂 作者 Carson_Ho 关注2017.01.06 11:20 字数 5427 阅读 429评论 10喜欢 51 前言Android事件分发机制是Android开发者必须了解的基础网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题；所以，请各位读者先记住结论，再往下继续看分析；文章较长，阅读需要较长时间，建议收藏等充足时间再进行阅读目录 目录 基础认知 1.1 事件分发的对象是谁？ 答：事件当用户触摸屏幕时（View或ViewGroup派生的控件），将产生点击事件（Touch事件）。Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象主要发生的Touch事件有如下四种：MotionEvent.ACTION_DOWN：按下View（所有事件的开始）MotionEvent.ACTION_MOVE：滑动ViewMotionEvent.ACTION_CANCEL：非人为原因结束本次事件MotionEvent.ACTION_UP：抬起View（与DOWN对应）事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件 任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图：事件列 即当一个MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 1.2 事件分发的本质 答：将点击事件（MotionEvent）向某个View进行传递并最终得到处理 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。 1.3 事件在哪些对象之间进行传递？ 答：Activity、ViewGroup、View 一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; ViewAndroid的UI界面是由Activity、ViewGroup、View及其派生类组合而成的UI界面 View是所有UI组件的基类一般Button、ImageView、TextView等控件都是继承父类ViewViewGroup是容纳UI组件的容器，即一组View的集合（包含很多子View和子VewGroup），其本身也是从View派生的，即ViewGroup是View的子类是Android所有布局的父类或间接父类：项目用到的布局（LinearLayout、RelativeLayout等），都继承自ViewGroup，即属于ViewGroup子类。与普通View的区别：ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。1.4 事件分发过程由哪些方法协作完成？ 答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 事件分发相关方法 下文会对这3个方法进行详细介绍 1.5 总结Android事件分发机制的本质是要解决：点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。这里的对象是指Activity、ViewGroup、ViewAndroid中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成经过上述3个问题，相信大家已经对Android的事件分发有了感性的认知，接下来，我将详细介绍Android事件分发机制。 事件分发机制方法&amp;流程介绍事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成，如下图： 方法详细介绍Android事件分发流程如下：（必须熟记）Android事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View 事件分发机制详细流程 其中：super：调用父类方法true：消费事件，即事件不继续往下传递false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理接下来，我将详细介绍这3个方法及相关流程。 2.1 dispatchTouchEvent()属性介绍使用对象Activity、ViewGroup、View作用分发点击事件调用时刻当点击事件能够传递给当前View时，该方法就会被调用返回结果是否消费当前事件，详细情况如下： 默认情况：根据当前对象的不同而返回方法不同对象返回方法备注Activitysuper.dispatchTouchEvent()即调用父类ViewGroup的dispatchTouchEvent()ViewGrouponIntercepTouchEvent()即调用自身的onIntercepTouchEvent()ViewonTouchEvent（）即调用自身的onTouchEvent（） 流程解析 返回true消费事件事件不会往下传递后续事件（Move、Up）会继续分发到该View流程图如下： 流程图 返回false不消费事件事件不会往下传递将事件回传给父控件的onTouchEvent()处理Activity例外：返回false=消费事件后续事件（Move、Up）会继续分发到该View(与onTouchEvent()区别）流程图如下：流程图 2.2 onTouchEvent()属性介绍使用对象Activity、ViewGroup、View作用处理点击事件调用时刻在dispatchTouchEvent()内部调用返回结果是否消费（处理）当前事件，详细情况如下：与dispatchTouchEvent()类似 返回true自己处理（消费）该事情事件停止传递该事件序列的后续事件（Move、Up）让其处理；流程图如下：流程图 返回false（同默认实现：调用父类onTouchEvent()）不处理（消费）该事件事件往上传递给父控件的onTouchEvent()处理当前View不再接受此事件列的其他事件（Move、Up）；流程图如下：流程图 2.3 onInterceptTouchEvent()属性介绍使用对象ViewGroup（注：Activity、View都没该方法）作用拦截事件，即自己处理该事件调用时刻在ViewGroup的dispatchTouchEvent()内部调用返回结果是否拦截当前事件，详细情况如下： 返回结果流程图如下： 流程图 2.4 三者关系 下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则 // 点击事件产生后，会直接调用dispatchTouchEvent（）方法public boolean dispatchTouchEvent(MotionEvent ev) { //代表是否消耗事件 boolean consume = false; if (onInterceptTouchEvent(ev)) { //如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件 //则该点击事件则会交给当前View进行处理 //即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; } else { //如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件 //则该点击事件则会继续传递给它的子元素 //子元素的dispatchTouchEvent（）就会被调用，重复上述过程 //直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; } return consume; } 2.5 总结对于事件分发的3个方法，你应该清楚了解接下来，我将开始介绍Android事件分发的常见流程 事件分发场景介绍 下面我将利用例子来说明常见的点击事件传递情况 3.1 背景描述 我们将要讨论的布局层次如下： 布局层次最外层：Activiy A，包含两个子View：ViewGroup B、View C中间层：ViewGroup B，包含一个子View：View C最内层：View C假设用户首先触摸到屏幕上View C上的某个点（如图中黄色区域），那么Action_DOWN事件就在该点产生，然后用户移动手指并最后离开屏幕。 3.2 一般的事件传递情况 一般的事件传递场景有：默认情况处理事件拦截DOWN事件拦截后续事件（MOVE、UP）3.2.1 默认情况即不对控件里的方法(dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent())进行重写或更改返回值那么调用的是这3个方法的默认实现：调用父类的方法事件传递情况：（如图下所示）从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent()再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent() 流程图 注：虽然ViewGroup B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent的行为是不一样的。 3.2.2 处理事件 假设View C希望处理这个点击事件，即C被设置成可点击的（Clickable）或者覆写了C的onTouchEvent方法返回true。 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图）DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理这个事件因为C正在处理这个事件，那么DOWN事件将不再往上传递给B和A的onTouchEvent()；该事件列的其他事件（Move、Up）也将传递给C的onTouchEvent() 流程图 3.2.3 拦截DOWN事件 假设ViewGroup B希望处理这个点击事件，即B覆写了onInterceptTouchEvent()返回true、onTouchEvent()返回true。 事件传递情况：（如下图）DOWN事件被传递给B的onInterceptTouchEvent()方法，该方法返回true，表示拦截这个事件，即自己处理这个事件（不再往下传递）调用onTouchEvent()处理事件（DOWN事件将不再往上传递给A的onTouchEvent()）该事件列的其他事件（Move、Up）将直接传递给B的onTouchEvent()该事件列的其他事件（Move、Up）将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。 流程图 3.2.4 拦截DOWN的后续事件 假设ViewGroup B没有拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件。DOWN事件传递到C的onTouchEvent方法，返回了true。在后续到来的MOVE事件，B的onInterceptTouchEvent方法返回true拦截该MOVE事件，但该事件并没有传递给B；这个MOVE事件将会被系统变成一个CANCEL事件传递给C的onTouchEvent方法后续又来了一个MOVE事件，该MOVE事件才会直接传递给B的onTouchEvent()后续事件将直接传递给B的onTouchEvent()处理后续事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。C再也不会收到该事件列产生的后续事件。流程图 特别注意：如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View；该事件不会再传递给ViewGroup A的onTouchEvent()只有再到来的事件才会传递到ViewGroup A的onTouchEvent()3.3 总结对于Android的事件分发机制，你应该已经非常清楚了如果你只是希望了解Android事件分发机制而不想深入了解，那么你可以离开这篇文章了对于程序猿来说，知其然还需要知其所以然，接下来，我将通过源码分析来深入了解Android事件分发机制 Android事件分发机制源码分析Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View，再次贴出下图： 事件分发机制详细流程 其中：super：调用父类方法true：消费事件，即事件不继续往下传递false：不消费事件，事件继续往下传递 / 交由给父控件onTouchEvent（）处理所以，要想充分理解Android分发机制，本质上是要理解：Activity对点击事件的分发机制ViewGroup对点击事件的分发机制View对点击事件的分发机制接下来，我将通过源码分析详细介绍Activity、View和ViewGroup的事件分发机制 4.1 Activity的事件分发机制 4.1.1 源码分析当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发具体是由Activity的Window来完成我们来看下Activity的dispatchTouchEvent()的源码public boolean dispatchTouchEvent(MotionEvent ev) { //关注点1 //一般事件列开始都是DOWN，所以这里基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) { //关注点2 onUserInteraction(); } //关注点3 if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 关注点1 一般事件列开始都是DOWN（按下按钮），所以这里返回true，执行onUserInteraction() 关注点2 先来看下onUserInteraction()源码 /** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and {@link #onUserLeaveHint} are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity&apos;s {@link #onUserLeaveHint} callback will * be accompanied by calls to {@link #onUserInteraction}. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */ public void onUserInteraction() { } 从源码可以看出：该方法为空方法从注释得知：当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法所以onUserInteraction()主要用于屏保关注点3Window类是抽象类，且PhoneWindow是Window类的唯一实现类superDispatchTouchEvent(ev)是抽象方法，返回的是一个Window对象通过PhoneWindow类中看一下superDispatchTouchEvent()的作用@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); //mDecor是DecorView的实例//DecorView是视图的顶层view，继承自FrameLayout，是所有界面的父类 } 接下来我们看mDecor.superDispatchTouchEvent(event)：public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); //DecorView继承自FrameLayout//那么它的父类就是ViewGroup 而super.dispatchTouchEvent(event)方法，其实就应该是ViewGroup的dispatchTouchEvent() } 所以：执行getWindow().superDispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event)再回到最初的代码：public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { //关注点2 onUserInteraction(); } //关注点3 if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); }由于一般事件列开始都是DOWN，所以这里返回true，基本上都会进入getWindow().superDispatchTouchEvent(ev)的判断 所以，执行Activity.dispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event)这样事件就从 Activity 传递到了 ViewGroup4.1.2 汇总 当一个点击事件发生时，调用顺序如下事件最先传到Activity的dispatchTouchEvent()进行事件分发调用Window类实现类PhoneWindow的superDispatchTouchEvent()调用DecorView的superDispatchTouchEvent()最终调用DecorView父类的dispatchTouchEvent()，即ViewGroup的dispatchTouchEvent()4.1.3 结论当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法如果ViewGroup的dispatchTouchEvent()返回true就不执行Activity的onTouchEvent()方法；如果返回false，就执行。这样事件就从 Activity 传递到了 ViewGroup4.1.4 疑问 那么，ViewGroup的dispatchTouchEvent()什么时候返回true，什么时候返回false？ 答：请继续往下看ViewGroup事件的分发机制 4.2 ViewGroup事件的分发机制 在讲解ViewGroup事件的分发机制之前我们先来看个Demo 4.2.1 Demo讲解 布局如下： 布局层次 结果测试： 只点击Button 只点击Button 再点击空白处 点击空白处 从上面的测试结果发现：当点击Button时，执行Button的onClick()，但ViewGroupLayout注册的onTouch（）不会执行只有点击空白区域时才会执行ViewGroupLayout的onTouch（）;结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。接下来，我们开始进行ViewGroup事件分发的源码分析 4.2.2 源码分析 ViewGroup的dispatchTouchEvent()源码分析详情请看注释Android 5.0后ViewGroup的dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同；本文为了让读者更好理解dispatchTouchEvent()源码分析，所以采用Android 5.0前的版本public boolean dispatchTouchEvent(MotionEvent ev) { final int action = ev.getAction(); final float xf = ev.getX(); final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX; final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (action == MotionEvent.ACTION_DOWN) { if (mMotionTarget != null) { mMotionTarget = null; } //看这个If判断语句//第一个判断值disallowIntercept：是否禁用事件拦截的功能(默认是false)//可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。//第二个判断值： !onInterceptTouchEvent(ev)：对onInterceptTouchEvent()返回值取反 //如果我们在onInterceptTouchEvent()中返回false，就会让第二个值为true，从而进入到条件判断的内部//如果我们在onInterceptTouchEvent()中返回true，就会让第二个值为false，从而跳出了这个条件判断。//关于onInterceptTouchEvent()请看下面分析（关注点1） if (disallowIntercept || !onInterceptTouchEvent(ev)) { ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; //通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { child.getHitRect(frame); //判断当前遍历的View是不是正在点击的View //如果是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) { final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; //关注点2 //条件判断的内部调用了该View的dispatchTouchEvent()方法（具体请看下面的View事件分发机制） //实现了点击事件从ViewGroup到View的传递 if (child.dispatchTouchEvent(ev)) { //调用子View的dispatchTouchEvent后是有返回值的 //如果这个控件是可点击的话，那么点击该控件时，dispatchTouchEvent的返回值必定是true //因此会导致条件判断成立 mMotionTarget = child; //于是给ViewGroup的dispatchTouchEvent方法直接返回了true，这样就导致后面的代码无法执行，直接跳出 //即把ViewGroup的touch事件拦截掉 return true; } } } } } } boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } final View target = mMotionTarget; //关注点3//没有任何View接收事件的情况，即点击空白处情况 if (target == null) { ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) { ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; } //调用ViewGroup的父类View的dispatchTouchEvent()//因此会执行ViewGroup的onTouch()、onTouchEvent()//实现了点击事件从ViewGroup到View的传递 return super.dispatchTouchEvent(ev); } //之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。 if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) { final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; ev.setAction(MotionEvent.ACTION_CANCEL); ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) { } mMotionTarget = null; return true; } if (isUpOrCancel) { mMotionTarget = null; } final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) { ev.setAction(MotionEvent.ACTION_CANCEL); target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; mMotionTarget = null; } return target.dispatchTouchEvent(ev); } 关注点1（onInterceptTouchEvent()源码分析） ViewGroup每次在做分发时，需要调用onInterceptTouchEvent()是否拦截事件；源码分析如下： public boolean onInterceptTouchEvent(MotionEvent ev) { return false; }返回false =不拦截（默认），允许事件继续往下传递(向子View传递)；因为子View也需要该事件，所以onInterceptTouchEvent拦截器return super.onInterceptTouchEvent()和return false是一样的 = 不会拦截返回true = 拦截（手动设置），即自己处理该事件（执行自己的onTouchEvent()），事件不会继续往下传递关注点2 当点击了某个控件：调用该控件所在布局（ViewGroup）的dispatchTouchEvent()在布局的dispatchTouchEvent()中找到被点击的相应控件再去调用该控件的dispatchTouchEvent()实现了点击事件从ViewGroup到View的传递此处是关于View.dispatchTouchEvent()的分析，详情请看下面的View事件分发机制。结论Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递；返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false）子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。4.3 View事件的分发机制 View中dispatchTouchEvent()的源码分析 public boolean dispatchTouchEvent(MotionEvent event) { if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) { return true; } return onTouchEvent(event); } 从上面可以看出：只有以下三个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent(event)方法第一个条件：mOnTouchListener != null； 第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED； 第三个条件：mOnTouchListener.onTouch(this, event)； 下面，我们来看看下这三个判断条件：第一个条件：mOnTouchListener!= null //mOnTouchListener是在View类下setOnTouchListener方法里赋值的public void setOnTouchListener(OnTouchListener l) { //即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空） mOnTouchListener = l; } 第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED该条件是判断当前点击的控件是否enable由于很多View默认是enable的，因此该条件恒定为true第三个条件：mOnTouchListener.onTouch(this, event)回调控件注册Touch事件时的onTouch方法//手动调用设置 button.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return false; } }); 如果在onTouch方法返回true，就会让上述三个条件全部成立，从而整个方法直接返回true。如果在onTouch方法里返回false，就会去执行onTouchEvent(event)方法。接下来，我们继续看：onTouchEvent(event)的源码分析详情请看注释Android 5.0后View的onTouchEvent()的源码发生了变化（更加复杂），但原理相同；本文为了让读者更好理解onTouchEvent()源码分析，所以采用Android 5.0前的版本public boolean onTouchEvent(MotionEvent event) { final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //如果该控件是可以点击的就会进入到下两行的switch判断中去； if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) { //如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。 switch (event.getAction()) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; // 在经过种种判断之后，会执行到关注点1的performClick()方法。 //请往下看关注点1 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) { // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (!mHasPerformedLongPress) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { //关注点1 //请往下看performClick()的源码分析 performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); } } break; } //如果该控件是可以点击的，就一定会返回true return true; } //如果该控件是可以点击的，就一定会返回false return false; } 关注点1： performClick()的源码分析 public boolean performClick() { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; } return false; }只要mOnClickListener不为null，就会去调用onClick方法；那么，mOnClickListener又是在哪里赋值的呢？请继续看：public void setOnClickListener(OnClickListener l) { if (!isClickable()) { setClickable(true); } mOnClickListener = l; }当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值（不为空），即会回调onClick（）。结论onTouch（）的执行高于onClick（）每当控件被点击时：如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。onTouch()返回false（该事件没被onTouch()消费掉） = dispatchTouchEvent()返回false（继续向下传递） = 执行onTouchEvent() = 执行OnClick()如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行；onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick()下面我将用Demo验证上述的结论 Demo论证 Demo1：在回调onTouch()里返回true Demo流程 //设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { System.out.println(&quot;执行了onTouch(), 动作是:&quot; + event.getAction()); return true; } }); //设置OnClickListener button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { System.out.println(&quot;执行了onClick()&quot;); } }); 点击Button，测试结果如下： 测试结果 Demo2：在回调onTouch()里返回false Demo流程 //设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { System.out.println(&quot;执行了onTouch(), 动作是:&quot; + event.getAction()); return false; } }); //设置OnClickListener button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { System.out.println(&quot;执行了onClick()&quot;); } }); 点击Button，测试结果如下： 测试结果 总结：onTouch()返回true就认为该事件被onTouch()消费掉，因而不会再继续向下传递，即不会执行OnClick()。 如果你看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了（Activity、ViewGroup、View的事件分发机制） 思考点 5.1 onTouch()和onTouchEvent()的区别这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。特别注意：请看下面代码//&amp;&amp;为短路与，即如果前面条件为false，将不再往下执行//所以，onTouch能够得到执行需要两个前提条件：//1. mOnTouchListener的值不能为空//2. 当前点击的控件必须是enable的。 mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event) 因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。5.2 Touch事件的后续事件（MOVE、UP）层级传递如果给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等）当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP）即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE和ACTION_UP事件都不会执行从上面对事件分发机制分析知：dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true）而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）这里给出ACTION_MOVE和ACTION_UP事件的传递结论：如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP黑线：ACTION_DOWN事件传递方向 红线：ACTION_MOVE和ACTION_UP事件传递方向 流程讲解如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。黑线：ACTION_DOWN事件传递方向 红线：ACTION_MOVE和ACTION_UP事件传递方向","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-09-07T06:43:08.351Z","updated":"2017-09-07T06:43:08.351Z","comments":true,"path":"2017/09/07/hello-world/","link":"","permalink":"http://yoursite.com/2017/09/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}